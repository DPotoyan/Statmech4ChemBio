Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# Reinitialize all missing parameters
D = 1  # Diffusion coefficient
x_min, x_max = -10, 10  # Spatial range
num_points = 200  # Number of spatial points
dx = (x_max - x_min) / (num_points - 1)  # Spatial step

# Stability condition: Ensure alpha <= 0.5
dt = 0.4 * dx**2 / D  # Choose dt to satisfy stability

num_frames = 500  # Number of time steps
alpha = D * dt / dx**2  # Compute new alpha

# Discretized space
x = np.linspace(x_min, x_max, num_points)
sigma_t = lambda t: np.sqrt(2 * D * t)  # Standard deviation of the Gaussian

# Recompute missing variables
time_steps = [0, 100, 250, 500]  # Key time steps for snapshots
snapshots_numerical = []
snapshots_analytical = []

# Reinitialize numerical solution
rho_numerical = np.exp(-x**2 / (2 * sigma_t(0.1)**2)) / np.sqrt(2 * np.pi * sigma_t(0.1)**2)
rho_numerical /= np.trapz(rho_numerical, x)  # Normalize

for step in range(num_frames + 1):
    t = step * dt + 0.1  # Avoid division by zero at t=0

    # Analytical solution
    rho_analytical = (1 / np.sqrt(2 * np.pi * sigma_t(t)**2)) * np.exp(-x**2 / (2 * sigma_t(t)**2))

    # Numerical solution using finite difference explicit method
    rho_new = rho_numerical.copy()
    rho_new[1:-1] = rho_numerical[1:-1] + alpha * (rho_numerical[2:] - 2 * rho_numerical[1:-1] + rho_numerical[:-2])
    
    rho_numerical[:] = rho_new  # Update state

    # Store snapshots at selected time steps
    if step in time_steps:
        snapshots_numerical.append(rho_numerical.copy())
        snapshots_analytical.append(rho_analytical.copy())

# Create figure with two panels: one for probability density, one for flux
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Generate colors from a sequential colormap
cmap = cm.viridis  # Perceptually uniform colormap
colors = [cmap(i / len(time_steps)) for i in range(len(time_steps))]  # Sequential colors

# Plot probability density evolution
for i, step in enumerate(time_steps):
    axes[0].plot(x, snapshots_numerical[i], label=f"Numerical (t={step * dt:.1f})", linestyle="-", marker="o", markersize=2, color=colors[i])
    axes[0].plot(x, snapshots_analytical[i], linestyle="--", color=colors[i], alpha=0.7)  # Faded analytical curve

axes[0].set_xlim(x_min, x_max)
axes[0].set_ylim(0, 0.5)
axes[0].set_xlabel("Position (x)", fontsize=12)
axes[0].set_ylabel("Probability Density $\\rho(x,t)$", fontsize=12)
axes[0].set_title("Time Sequence of 1D Diffusion Evolution", fontsize=14)
axes[0].legend()
axes[0].grid(alpha=0.3)

# Compute and plot flux evolution
for i, step in enumerate(time_steps):
    J_numerical = -D * np.gradient(snapshots_numerical[i], x)  # Numerical flux
    J_analytical = -D * np.gradient(snapshots_analytical[i], x)  # Analytical flux

    axes[1].plot(x, J_numerical, label=f"Numerical (t={step * dt:.1f})", linestyle="-", marker="o", markersize=2, color=colors[i])
    axes[1].plot(x, J_analytical, linestyle="--", color=colors[i], alpha=0.7)  # Faded analytical curve

axes[1].set_xlim(x_min, x_max)
axes[1].set_xlabel("Position (x)", fontsize=12)
axes[1].set_ylabel("Probability Flux $J(x,t)$", fontsize=12)
axes[1].set_title("Time Sequence of Probability Flux Evolution", fontsize=14)
axes[1].legend()
axes[1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[6], line 47[0m
[1;32m     44[0m fig, axes [38;5;241m=[39m plt[38;5;241m.[39msubplots([38;5;241m1[39m, [38;5;241m2[39m, figsize[38;5;241m=[39m([38;5;241m12[39m, [38;5;241m5[39m))
[1;32m     46[0m [38;5;66;03m# Generate colors from a sequential colormap[39;00m
[0;32m---> 47[0m cmap [38;5;241m=[39m [43mcm[49m[38;5;241m.[39mviridis  [38;5;66;03m# Perceptually uniform colormap[39;00m
[1;32m     48[0m colors [38;5;241m=[39m [cmap(i [38;5;241m/[39m [38;5;28mlen[39m(time_steps)) [38;5;28;01mfor[39;00m i [38;5;129;01min[39;00m [38;5;28mrange[39m([38;5;28mlen[39m(time_steps))]  [38;5;66;03m# Sequential colors[39;00m
[1;32m     50[0m [38;5;66;03m# Plot probability density evolution[39;00m

[0;31mNameError[0m: name 'cm' is not defined

